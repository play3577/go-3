MCTS algorithm
1. Create root node
2. Set root as current
3. If current has children:
  a. Find best child according to selection algorithm
  b. Set child as current
  c. Go to 3
4. If current is leaf (no children): 
  a. If current is game over:
    a. Go to 2 (?)
  b. If current is not game over:
    a. Find a random next move
    b. Create a child node for this move
    c. Make a playout from child node
    d. Propagate results to each parent
    e. Go to 2 (if not timeout)

Selection algorithm:
calculate k = C * sqrt(ln(current.visits))
return child with max UCB = (child.wins/child.visits) + k * 1/sqrt(visits)

Results propagation:
do:
  increment current.visits
  if result was a win:
    increment current.wins
  current = current.parent
while current is not root;

teresa_node {
	teresa_node* sibling;
	teresa_node* parent;
	teresa_node* child;
	color pl;
	move move;
	int wins;
	int visits;
}

TODO (Problems with Teresa's algorithm)
 - Each player would try to maximize his own UCB score, not that of the player currently thinking.
 - Handle game-overs correctly
 - Need better debugging tools w/ more accurate & understandable info
 - Currently tends to favor passing twice at some point (even though this theoretically results in a 100% loss) --> why?

Pseudocode:
C := params.C;
root := params.root;
while can still think:
  current := root
  state := clone(state0)

  // Selection
  while current has children:
    k := C * sqrt(ln(current.visits))
    for each child:
      if child.visits == 0:
        UCB := Infinity
      else:
        UCB := (child.wins/child.visits) + k * 1/sqrt(child.visits)
    find child with highest UCB for that player (randomly if tied)

    current := child with highest UCB
    play_move(state, current.move)

  if is_game_over(state):
    destroy(state)
    continue;

  // Expansion
  list := get_legal_moves(state);
  for each move in list:
    create child node {parent: current, move: move, wins: 0, visits: 0}

  // Simulation
  current := random child node;
  play_move(state, current.move)
  result = play_out(state)
  
  // Back-propagation
  do:
    ++current.visits
    if result.win:
      ++current.wins
    current = current.parent
  while current != root;
  destroy(state);



Things to do to make chess:

V   chess_get_reasonable_moves
V     chess_is_move_reasonable
V       chess_is_move_legal
    chess_play_move: assume move pseudo-legal; make sure king not in check, make move, update status if applicable
    chess_play_out: straightforward
       chess_play_random_move: play any random move; pick any pseudolegal move, attempt to play it, make sure king not in check?

Assume following moves are all pseudo-legal (pieces move according to their rules, may capture opponents).
Assume my king not in check.
  I move a non-king piece, and my king is now in check.
    An opposing Queen, Rook or Bishop will capture him.
    > Check horz & vert around my old location to see if my king is on one side, a {rook or queen} on the other,
    > and check both diag around my old location to see if my king is on one side, a {bishop or queen} on the other.
    > If my move goes out of the line, declare illegal.
  I move my king, and my king is now in check.
    Any opponent could capture him.
    > If the new square were already under attack from any opponent, declare illegal.
Assume my king is in check / is on a square being attacked.
  I move a non-king piece, and my king is still in check.
    > After simulating the move only on the board, check if the king is still under attack. If so, declare illegal.
  I move my king, and my king is still in check.
    > After simulating the move only on the board, check if the king is still under attack. If so, declare illegal.















